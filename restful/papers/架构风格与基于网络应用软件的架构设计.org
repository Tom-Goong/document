#+LATEX_HEADER: \usepackage{xltxtra}
#+LATEX_HEADER: \setmainfont{Songti SC}
#+LATEX_HEADER: \usepackage{seqsplit}
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil tasks:nil pri:nil title:t
#+TITLE: 架构风格与基于网络应用软件的架构设计 -- 学习笔记
* 写在前面
  本文是学习论文的笔记，不是翻译。所以会有不同于原著的东西，甚至不同的看法。另外可能有不少错误，欢迎指正。
  一下是一些变动
  - 每章的"小节"部分被移到每章开头的"本章摘要"，目的是明确这章的重点。
* 摘要
* 绪论
** 架构研究面
   软件架构方面的研究探索是*如何以最佳的方式划分一个系统、如何标识一个组件、组件之间如何通信、信息如何表达、组成系统的元素如何独立地进化，以及上述所有内容如何使用形式话的和非形式化的符号加以描述*
** 架构设计的考虑方面
   - 系统的功能
   - 系统的行为
   - 系统的社交
** 错误的观点：形式追随功能
* 章节
** 软件架构
*** 本章摘要
    本章的作用是叙述了论文的背景，介绍了相关概念的发展情况，并以此提出作者自己的完备的软件架构概念术语。这一章是读懂本论文的基础，认识了基本概念，才能正确学习下面文章。
*** 运行时抽象(Run-time Abstraction)
    *软件架构*: 是一个软件系统在其运行过程中某个阶段的运行时元素的抽象。一个系统可能由很多层抽象和很多个运行阶段组成，每一个抽象和运行阶段都有自己的软件架构
**** 软件架构的核心：抽象原则
     通过封装来隐藏系统的一些细节，从而更好的识别和支持系统的架构属性。一个复杂的系统会包含很多层抽象，每层是抽象都有自己的架构。架构代表了在某个层次上系统行为的抽象，架构元素可以通过自身提供给同一层其他元素的抽象接口来描述。在每个架构元素之中，可能还存在另外一个架构，由其定义由众多子元素构成的系统元素。如此递归直到最基本元素。
     系统软件通常还有多个运行阶段，如启动、初始化、正常处理、重新初始化和停止。每个运行阶段都有自己的架构。比如通常配置文件在启动阶段是架构的一个数据元素来处理，但是正常业务处理阶段，不是一个架构元素。系统架构的整体描述必须既能够描述各个阶段的系统架构行为，也能够描述在各个阶段之间的架构的迁移。
**** 软件架构与软件结构
     软件架构是软件系统在运行时的抽象，而软件结构是静态源代码的属性。
*** 架构元素(Elements)
    *架构元素*: 软件架构是由一些架构元素（组件、连接器和数据）的配置来定义的，这些元素之间的关系受到约束，以获得多期待的一组架构属性
**** 组件(Components)
     *组件*: 软件指令和内部状态的一个抽象单元，通过接口提供对于数据的转换。
     组件应该由它为其他组件提供的接口额服务来定义，而不是由它在接口后面的实现来定义。
**** 连接器(Connectors)
     *连接器*: 是对于组件之间的通讯、协调或者合作进行仲裁的一种抽象机制。
     - 共享的表述
     - 远程过程调用
     - 消息传递协议
     - 数据流
     - ...
**** 数据(Data)
     *数据*: 数据是组件通过一个连接器接受或发送的信息元素
     - 字节序列
     - 消息
     - 编码过的参数
     - 序列化的对象
     - (不包括永久驻留或隐藏在组件中的信息)
*** 配置
    *配置*: 在系统的运行期间组件、连接器和数据之间的架构关系的结构
*** 属性
    软件架构的架构属性，包括了对组建、连接器和数据的选择和排列所导致的所有属性。包括系统获得的功能属性和非功能属性。
    属性是由架构中的一组约束产生的。约束往往是由在架构元素的某个方面应用软件工程原则来驱动。
    例如，统一管道和过滤器风格通过在其组建接口之上应用通用性原则，强迫组件实现单一的接口类型。从应用中获得了组建的可重用性和可配置性的品质。
    架构设计的目标是创建一个包括一组架构属性的架构，这些架构属性形成了系统需求的一个超级。
*** 风格
    *架构风格*: 是一组协作的架构约束，这些约束限制了架构元素的角色和功能，以及在任何一个循序该风格的架构中允许存在的元素之间的关系。
    风格是一种用来对架构进行分类和定义它们的公共特征的机制。每一种风格都为组建的交互提供了一种抽象，并且通过忽略架构中其余部分的偶然性细节，来捕获一种交互模式的本质特征。
    架构风格用作一种进行抽象的方法，而不是代表一种个性化的设计
*** 模式和模式语言
    *设计模式*: 是一种重要的和重复出现的系统构造。
    *模式语言*: 是一个模式的系统，对这些模式的应用加以指导和组织。
*** 视图
*** 相关工作
**** 设计方法学
**** 设计、设计模式、模式语言手册
**** 参考模型和特定与领域的软件架构
**** 架构描述语言
**** 形式化的架构模型
** 基于网络的应用的架构
*** 本章摘要
    本章主要讨论基于网络应用的架构，并描述架构风格如果指导架构的设计。同时确定了本论文的讨论范围，定义架构属性的集合。
*** 范围
    该论文讨论的软件架构是在最高层次上的抽象，通过网络通信来实现组件之间的交互。
**** 基于网络 VS 分布式
     网络架构和软件架构的主要区别：组件之间的通信仅限于消息传递或者消息传递的等价物。
**** 应用软件 VS 网络软件
     本论文的讨论范围仅局限在应用软件的架构，不包括操作系统、网络软件和一些仅仅为得到系统支持而使用的网络架构风格(进程控制风格)
*** 评估应用软件架构的设计
    - 由应用的功能需求来设定
*** 关键关注点的架构属性
**** 性能(Performance)
***** 网络性能(Network Performance)
      - 吞吐量
      - 负载
      - 宽带
***** 用户可察觉的性能(User-perceived Performance)
      *延迟*: 出发初次请求到得到第一个响应指示之间持续的时间。处理过程有下面几个点：
      1. 应用识别出触发动作的事件所需的时间
      2. 在组件之间建立交互所需的时间
      3. 在组件间传输交互数据所需的时间
      4. 组件处理每个交互所需的时间
      5. 应用能够呈现一个可用的结果之前，完成数据的转移和处理交互的结果所需的时间
      *完成时间*: 完成一个应用动作所话费的时间。取决上述所有的延迟点。
      如果优化以减少延迟，通常会延长完成时间，反过来也一样。
***** 网络效率(Network Efficiency)
      在基于网络的应用架构中，最佳的应用性能往往是尽可能减少网络交互而达到的。
**** TODO 可伸缩性(Scalability)
**** 简单性(Simplcity)
     主要方法: 对组件之间的功能分配时，应用分离关注点原则(principle of separation of concerns)。如果功能分配使得单独的组件足够简单，那么就容易被理解和实现。同时也就保证了复杂性，可理解性和可验证性合理状态。
     同时对架构元素应用通用型(principle of generality)有助于提高简单性。(例如中间件就是通用性原则在连接器上的应用结果)
**** 修改性(Modifiability)
     可修改性指：对于应用的架构所作的修改的难易程度，具体分为下面几个方面。此外，基于网络的系统特别关注动态的可修改性。
***** 可进化性(Evolvability)
      表示一个组件能够被改变而不会对其他组件产生负面影响的程度。
***** 可扩展性(Extensibility)
      指将功能添加到一个系统的能力。动态可扩展性意味着功能能够被添加到一个已部署的系统中，而不会影响到系统的其他部分。注意减少组件之间的耦合是一个基本方法
***** 可定制性(Customizability)
      指临时性地规定一个架构元素的行为的能力，然后该元素能够提供一种非常规的服务。一个组件可定制，指一个客户能够扩展该组件的服务，而不会对该组件的其他客户产生影响。
      支持可定制的风格可以提高简单性和可扩展性，因为通过仅仅直接实现最常用的服务，允许客户端来定义不常用的服务，服务组件的尺寸和复杂性将会降低。
      可定制性是通过远程求值风格和按需代码风格所导致的一种架构属性。
***** 可配置性(Configurability)
      可配置性与可扩展性有关，也与重用性有关，指在部署后，对于组件或组件配置的修改，这样组件能够使用新的服务或者新的数据元素类型。
      管道和过滤器风格和按需代码风格是两个可以分别为组件配置和组件带来可配置性的例子。
***** 可重用性(Reusability)
      一个应用的架构中的组件、连接器或数据元素能够在不做修改的情况下在其他应用中重用，那么该架构就是具有可重用性。
      实现的方式主要有：降低组件之间的耦合，强制使用通用的组件接口。(统一管道和过滤器风格)
**** 可见性(Visibility)
     *可见性*: 一个组件对于其他两个组件之间的交互进行监视或仲裁的能力。
     通过限制必须使用通用性的接口，或者提供访问监视功能的方法，来影响基于网络的应用中交互的可见性。可以通过一下方式改善：
     - 交互的共享缓存
     - 通过分层服务提供可伸缩性
     - 通过反射式监视提供可靠性
     - 通过允许中间组件对交互做检查提供安全性(网络防火墙)
     (移动代理风格是缺乏可见性可能导致安全问题的一个例子)
**** 可移植性(Portability)
     指软件能够在不同的环境下运行。会带来可移植性属性的风格包括哪些将代码和代码所要处理的数据一起移动的风格(例如虚拟机和移动代理风格)，以及那些限制只能使用标准格式的数据元素的风格。
**** 可靠性(Reliability)
     从应用的架构角度来说，可靠性可以被看作当在组件、连接器或数据之中出现部分故障时，一个架构容易受到系统层面故障影响的程度。架构风格能够通过一下方法提高可靠性：
     - 避免单点故障
     - 增加冗余
     - 允许监视
     - 可恢复的动作来缩小故障的范围
** 基于网络的架构风格
*** 本章摘要
    本章对基于网络的应用的常见架构风格进行汇总分类，调查他们的架构属性，以进行一个评估，汇总如下：
    | Style    | Derivation | Net         | UP          | Efficienty | Scalability | Evolvability | Extensibility | Customize | Configuration | Reusability | Visibility | Portability | Reliability |
    |          |            | Performance | Performance |            |             |              |               |           |               |             |            |             |             |
    |----------+------------+-------------+-------------+------------+-------------+--------------+---------------+-----------+---------------+-------------+------------+-------------+-------------|
    | PF       |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | UPF      | PF         | -           |             |            |             |              |               |           |               |             |            |             |             |
    | RR       |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | $        | RR         |             |             |            |             |              |               |           |               |             |            |             |             |
    | CS       |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | LS       |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | LCS      | CS+LS      |             |             |            |             |              |               |           |               |             |            |             |             |
    | CSS      | CS         |             |             |            |             |              |               |           |               |             |            |             |             |
    | C$SS     | CSS+$      |             |             |            |             |              |               |           |               |             |            |             |             |
    | LC$SS    | LCS+C$SS   |             |             |            |             |              |               |           |               |             |            |             |             |
    | RS       | CS         |             |             |            |             |              |               |           |               |             |            |             |             |
    | RDA      | CS         |             |             |            |             |              |               |           |               |             |            |             |             |
    | VM       |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | REV      | CS+VM      |             |             |            |             |              |               |           |               |             |            |             |             |
    | COD      | CS+VM      |             |             |            |             |              |               |           |               |             |            |             |             |
    | LCODC$SS | LC$SS+COD  |             |             |            |             |              |               |           |               |             |            |             |             |
    | MA       | REV+COD    |             |             |            |             |              |               |           |               |             |            |             |             |
    | EBI      |            |             |             |            |             |              |               |           |               |             |            |             |             |
    | C2       | EBI+LCS    |             |             |            |             |              |               |           |               |             |            |             |             |
    | DO       | CS+CS      |             |             |            |             |              |               |           |               |             |            |             |             |
    | BDO      | DO+LCS     |             |             |            |             |              |               |           |               |             |            |             |             |
*** 分类方法学
    软件的设计是为了满足或者超出一定的需求，在系统设计时选择的架构风格必须与所要满足的需求相一致。不同的架构风格又带来不同的架构属性，所以对架构风格进行分类时，要根据这些架构属性。
**** TODO 选择哪些架构风格来进行分类

**** TODO 风格所带来的架构属性

**** TODO 可视化
*** 数据流风格(Data-flow Styles)
    | Style | Derivation | Net         | UP          | Efficienty | Scalability | Simplicity | Evolvability | Extensibility | Customize | Configuration | Reusability | Visibility | Portability | Reliability |
    |       |            | Performance | Performance |            |             |            |              |               |           |               |             |            |             |             |
    |-------+------------+-------------+-------------+------------+-------------+------------+--------------+---------------+-----------+---------------+-------------+------------+-------------+-------------|
    | PF    |            |             | + -         |            |             | +          | +            | +             |           | +             | +           |            |             |             |
    | UPF   | PF         | -           | + -         |            |             | + +        | +            | +             |           | + +           | + +         | +          |             |             |
**** 管道和过滤器(Pile and Filter, PF)
     优点：
     - 简单性：将系统的全部输入、输入，当作个别过滤器行为的简单组合
     - 可重用性：任意过滤器可以连接在一起
     - 可扩展性：过滤器容易被维护和增强
     - 可进化性：过滤器容易升级
     - 可验证性：允许一些特性类型的专门性分析(例如吞吐量和死锁分析)
     - 用户可觉察的性能：天生支持并发
     缺点：
     - 过长的管道会导致延迟增加
     - 过滤器如果不能增量处理，则导致批量串行处理，此时不允许任何交互
     - 过滤器不能与环境交互
     - 看不见的手：为整个应用安排的过滤器的配置
**** 统一管道和过滤器(Uniform Pipe and Filter, UPF)
     在PF上增加约束：所有过滤器必须具有相同的接口。
     如果数据需要被转换为它的原始格式或者从它的原始格式转换为特定格式，这个约束会降低网络性能。
*** 复制风格(Replication Styles)
    | Style | Derivation | Net         | UP          | Efficienty | Scalability | Simplicity | Evolvability | Extensibility | Customize | Configuration | Reusability | Visibility | Portability | Reliability |
    |       |            | Performance | Performance |            |             |            |              |               |           |               |             |            |             |             |
    |-------+------------+-------------+-------------+------------+-------------+------------+--------------+---------------+-----------+---------------+-------------+------------+-------------+-------------|
    | RR    |            |             | + +         |            | +           |            |              |               |           |               |             |            |             | +           |
    | $     | RR         |             | +           | +          | +           |            |              |               |           |               |             |            |             |             |
**** 复制仓库(Replicated Repository, RR)
     基于复制仓库风格的系统通过利用多个进程提供相同的服务，来改善数据的可访问性和服务的可伸缩性。
     *维护一致性是RR风格的主要关注点*
**** 缓存(Cache, $)
     缓存风格当与客户-无状态-服务器结合后就成为了一种基于网络的架构风格。
*** 分层风格(Hierarchical Styles)
**** 客户-服务器(Client-Server, CS)
     分离关注点四在客户-服务器约束背后的原则。
**** 分层系统(Layered System, LS)和分层-客户-服务器(Layered-Client-Server. LCS)
**** 客户-无状态-服务器(Client-Stateless-Server, CSS)
     在客户-服务器风格上，添加了一个约束：在服务器组件之上不允许有会话状态。
     从客户端发到服务器的每个请求必须包含理解请求所必须的全部信息，不能利用任何保存在服务器上的上下文，会话保存在客户端。
     这些约束改善了可见性、可靠性、可伸缩性。
     缺点：我们不能将状态数据保存在服务器上的共享上下文中，通过增加在一些列请求中发送的重复数据，可能会降低网络性能。
**** 客户-缓存-无状态-服务器(Client-Cache-Stateless-Server, C$SS)

**** 分层-客户-缓存-无状态-服务器(Layered-Client-Cache-Stateless-Server, LC$SS)
     通过添加代理和／或网关组件，继承了分层-客户-服务器风格和客户-缓存-无状态-服务器风格。(范例：DNS系统)
     它的优缺点就是LCS和C$SS风格的优点和缺点集合。
**** 远程会话(Remote Session, RS)
     客户-服务器风格的变体。试图使用客户端组件的复杂性最小化或者使其可重用性最大化。
**** 远程数据访问(Remote Data Access, RDA)
     客户-服务器风格的变体。将应用状态分布在客户端和服务器上。
*** 移动代码风格(Moblile Code Style)
**** 虚拟机(Virtual Machine, VM)
     虚拟机(或解释器)风格是所有移动代码风格的基础。虚拟机是执行代码的环境，本身不是基于网络的风格，通常在客户-服务器风格中与一个组件结合使用。
**** 远程求值(Remote Evaluation, REV)
     来源于客户-服务器风格和虚拟机风格。
**** 按需代码(Code on Demand, COD)
     客户端知道如何访问数据，但不知道如何处理数据，需要向服务器获取处理代码，然后在本地运行。
**** 分层-按需代码-客户-缓存-无状态-服务器(Layered-Code-on-Demand-Client-Cache-Stateless-Server, LCODC$SS)

**** 移动代理(Modile Agent, MA)
*** 点对点风格(Peer-to-Peer Styles)
**** 基于事件的集成(Event-based Integration, EBI)
     基于事件的集成风格被称作隐式调用风格或者事件系统风格，通过除去了解连接器接口的标示的必要性，降低组件之间的耦合。
     此风格不是直接调用另一个组件，而是组件发布或广播一个或者多个事件。在事件发布后，系统中其他组件能够组册对于某些事件类型的兴趣，由系统本身来调用所有已组册的组件。
**** C2
     将基于事件的集成风格和分层-客户-服务器风格相结合。
**** 分布式对象(Distributed Objects, DO)

**** 被代理的分布式对象(Brokered Distributed Objects, BDO)
*** 局限
*** 相关工作
**** 架构风格和模式的分类方法
**** 分布式系统和编程范例
**** 中间件
** 设计Web架构：问题与洞察力
*** 本章摘要
    本章介绍万维网结构的需求和一些问题。
*** 万维网应用领域的需求
    Web的主要目的是一种共享信息的空间，通过Internet连接各个大学和研究所，因为各自的机器不经相同，文本也不一样，所以需要对分享的信息提供统一的、一致的接口。
**** 低门槛
     参与创建和构造Web上的分享信息是自愿的，所以需要一个“低门槛”的策略。并适用于Web架构的所有使用者：阅读者、创作者和应用的开发者。
     超媒体因为其简单性和通用性的特点，成为了用户接口。
     对于创作者而言，要求整个系统的部分可用性不至于妨碍内容的创作。超文本的语言也是简单的，能够使用现有的编辑工具来创建。
     对于应用开发者的利益，简单性也是一个目标。
**** 可扩展性
     简单性使得部署一个分布式系统的最初实现成为了可能，可扩展性使得我们避免了永远陷入已部署系统的局限之中。
**** 分布式超媒体
     超媒体是由应用控制信息来定义的，这些控制信息内嵌在信息的表述之中，或者作为信息的表述之上的一层。分布式超媒体允许在远程地点存储表述和控制信息。由于这个特性，一个分布式超媒体系统中的用户动作需要将大量的数据从其存储地转移到其他使用地。所以Web框架必须设计为支持大粒度的数据转移。
     用户可觉察的延迟(在选择一个链接和呈现可用的结果之间的时间)对于超媒体交互的可用性而言是高度敏感的。因为Web的信息源是跨越整个Internet分布的，这种架构必须使用网络交互(在数据转移协议中的往返时间)最小化。
**** Internet规模
     Web是指在成为一个Internet规模的分布式超媒体系统，这意味着它的内涵远远不只仅仅是地理上的分布。Internet是跨越组织边界互联连接的信息网络。信息服务的提供商必须能够应对无法孔子的可伸缩性和软件组件的独立部署两方面的需求。
***** 无法控制的可伸缩性
***** 独立部署
*** 问题
    - 我们如何将一组新的功能引入到一个已经被广泛部署的架构中
    - 如何确保新功能的引入不会对那些使用Web成功的架构属性带来不理的甚至是毁灭性的影响
*** TODO 推导方法(Approach)
    早起Web架构基于一些可靠的原则：分离关注点、简单性、通用型。但是缺乏对于架构的面熟和基本原理。
**** Step 1 在早期Wweb结构中，识别出那些能够带来想要的架构属性的约束。
     *假设一*: 在WWW结构背后的设计原本原理能够通过一种由应用于Web架构中元素之上的约束组合的架构风格来描述。
**** Step 2 识别出在一个Internet桂芬的分布式超媒体系统中想要得到的属性，然后选择额外的会带来这些属性的架构风格。
     *假设二*: 能够为WWW架构风格提那家约束，从而获得更好地反映一个现代Web架构想要得到的属性的新的混合风格。
** 表述性状态转移(REST)
*** 本章摘要
    本章详细介绍为分布式超媒体系统设计的表述行状态转移(REST)架构风格，命数了知道REST的软件工程原则和选择用来支持这些原则的交互约束，并将他们与其他框架风格的约束进行对比。
*** 推导REST
**** 从"空"风格开始
**** 客户-服务器
**** 无状态
**** 缓存
**** 统一接口
**** 分层系统
**** 按需代码
**** 风格推导小结
*** REST架构的元素
**** 数据元素(Data Elements)
***** 资源和资源标识符(Resources and Resource Identifiers)
***** 表述(Representations)
**** 连接器(Connectors)
**** 组件(Components)
*** REST架构的视图
**** 过程视图(Process View)
**** 连接器视图(Connector View)
**** 数据视图(Data View)
*** 相关工作
** 经验与评估
*** 本章摘要
*** Web标准化
*** 将REST应用URI
**** 重新定义资源
**** 操作影子(Manipulationg Shadows)
**** 远程创作(Remote Authoring)
**** 将语义绑定到URI
**** REST在URI中的不匹配
*** 将REST应用于HTTP
**** 可扩展性
***** 协议版本控制
***** 可扩展的协议元素
***** 升级
**** 自描述的消息
***** 主机
***** 分层的编码
***** 语义独立性
***** 传输独立性
***** 尺寸限制
***** 缓存控制
***** 内容协商
**** 性能
***** 持久连接
***** 直写式(write-through)缓存
**** REST在HTTP中的不匹配
***** 区分非权威的响应
***** Cookie
***** 必需扩展(Mandatory Etensions)
***** 混合元数据(Mixing Metadata)
***** MIME语法
**** 将响应匹配到请求
*** 技术迁移
**** libwww-perl的部署经验
**** Apache的部署经验
**** 开发顺从于URII和HTTP/1.1的软件
*** 架构上的教训
**** 基于网络的API的优势
**** HTTP并不是RPC
**** HTTP并不是一种传输协议
**** 媒体类型的设计
***** 一个基于网络的系统中的应用状态
***** 增量处理
***** Java vs. JavaScript
** 结论
